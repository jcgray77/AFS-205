Skaffold Overview

[Autogenerated] So what is scaffold? Well, based on what you've heard so far, you probably know that it could be used to convert from Dr Composed a Kubernetes. Otherwise, it probably wouldn't be in this course, but it could do some other things as well. I like to think of it this way. Scaffold equals local kubernetes development. Now, what I mean by that is when you use Docker compose on its own, it just runs containers locally and handles orchestrated those containers, but has nothing to do with kubernetes now. What's nice about it, though, is it can automatically build the images, run the containers and help you out that way, what scaffold does is very similar. It can also build your images and deploy your containers, but it will deploy those containers to the Kubernetes cluster that you choose now by default. If you're running something like Docker desktop, which I'll be doing or Mini Cube, then it's just going to use your local kubernetes cluster. But there are additional configuration options for running in a different cluster that might be located somewhere off prim. For example, here's how they officially define it. Scaffold handles the workflow for building pushing and deploying your application, allowing you to focus on what matters most riding coat. And that's what this is all about. If you, for instance, had a micro service type scenario and you want to run a bunch of containers simultaneously but maybe only develop against one or two of those, then scaffold would make it where you could still run everything in kubernetes as it would be more in a production scenario. But as you change your code, it can redeploy those change containers, and it even has some sinking features to speed that up. If you just need to redeploy some files and I'll walk you through some of that now, when it comes to Docker compose and scaffold, Scaffold actually uses the composed tool, the one that we covered previously. The starts with the K, and we know that that composed tool could be used to convert from Dr composed to kubernetes manifest files. Well, to do that, there's a command we're gonna cover called Scaffold in it, and it has a command line flag where we can define the doctor composed file under the covers. It will then run a process which is gonna be the composed process we covered earlier. And then they're gonna output those YAMMA files for kubernetes. Now it's also going to generate a type of build artifact file. We call it scaffold dot Yamil, and this is gonna be the file that will monitor your local code for changes, automatically rerun the doctor billed process and then even handle the deployment of that updated image to get that container for the image running in a pot and kubernetes. So you can think of this as someone analogous to the Yamil you'll see in Kubernetes. But it's very specific to building your scaffolding artifacts. So here's what a scaffold Thiemo file might look like. First, I feel notice that has an A P I version a kind and metadata much like you'd see with kubernetes manifests. And we're gonna define whatever the latest version is of scaffold in the AP version. Now moving on down to the build section, you'll notice that we have artifacts. In this case, we're gonna have an image called in genetics jumpstart the context of where it's going to be watching for changes to, for instance, source code files is gonna be the local folder wherever this scaffold at yamma file is, And then our docker file is also located in that location, at least in this example. Now, what will happen there is as we change our code, it will detect that and then automatically rebuild the image and deploy that to kubernetes. How does it know how to deploy the kubernetes, though? Well, as I mentioned earlier, under the covers thes scaffolding knit command, we're gonna learn more about uses the composed tool to convert your doctor composed file to kubernetes manifest files. So by running that it will generate the files and then we can point it to those with the manifest property that you see at the bottom here and now under the covers, it will run acute CTL command against the K eight s folder and all the amel files that are inside of it. So here's how this whole process kind of breaks down more visually. First off, it can detect source code changes, and it hasn't built in File sync to monitor those changes. Then we'll go ahead and build your artifacts, make sure they're working properly, even tagged them and then render the manifests that are needed. So that they could be deployed once that happens, then we would have an actual pod with containers in Kubernetes. And then it can even tell the logs and even do port 40. Now telling the logs, if you're not familiar with that, it basically exposes the logs to us so that we can see those directly, for example, in a console if we wanted. Now, once we're done with this, if you just hit control C to stop the console, then it will automatically do acute CTL delete type process and clean up. All the different resource is that we might have. And that's actually really, really nice. So you can get more information about this at the pipeline stages link that you're going to see towards the bottom. But everything I'm gonna be showing you is going to go through this process and it happens kind of autumn magically again just by running a single command. So before we look at those commands, let's see how we can get scaffold installed 